# -*- coding: utf-8 -*-
"""Optimization_MeanVarianceAllocation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CIZBklZFTg6wu7BlM_HBbP9wzwohwWjM

Implementation of the mean-variance selection problem with riskless borrowing/lending
"""

import numpy as np

# Variance-covariance matrix
Sigma = np.array([[0.04,0.025,0.012],[0.025,0.0625,-0.023],[0.012,-0.023,0.09]])

# Vector of expected (linear) returns
mu = np.array([0.04, 0.05, 0.06])

# (Linear) risk-free rate
rf = 0.02

# Target (linear) return
k = 0.1

from scipy.optimize import minimize

def objFct(w, covMatrix):
  portVar = np.dot(np.dot(w.T,covMatrix),w)
  return portVar

ones = np.ones(3)
EWP = ones/3 # equally weighted portfolio, always a good choice for the initial guess of an portfolio allocation problem

result = minimize(objFct, EWP, args = Sigma, \
                  constraints = ({'type': 'eq', 'fun': lambda w: np.dot(w.T,mu) +(1-np.dot(w.T,ones))*rf -k }) )

wstar = result.x

wstar

w_fstar = 1 -wstar.sum()
w_fstar

optimalVar = result.fun
optimalVar

invSigma = np.linalg.inv(Sigma)
H = np.dot(np.dot(mu -rf*ones, invSigma), mu-rf*ones)
wstar_CF = (k-rf)/H*np.dot(invSigma,mu -rf*ones)
wstar_CF

# with short-selling constraint

myBounds = ((0,None),(0,None),(0,None))

result_SSC = minimize(objFct, EWP, args = Sigma, bounds = myBounds, \
                  constraints = ({'type': 'eq', 'fun': lambda w: np.dot(w.T,mu) +(1-np.dot(w.T,ones))*rf -k }) )

wstar_SSC = result_SSC.x
wstar_SSC

optimalVar_SSC = result_SSC.fun
optimalVar_SSC